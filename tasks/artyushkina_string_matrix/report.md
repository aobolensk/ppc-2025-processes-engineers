# Нахождение минимальных элементов в строках матрицы

- Студент: Артюшкина Юлия Дмитриевна, группа 3823Б1ПР4
- Технология: SEQ|MPI
- Вариант: 17


## 1. Введение
Обработка матричных данных является фундаментальной задачей в вычислительной математике и анализе данных. Определение минимальных значений в каждой строке матрицы находит применение в:
- Предварительной обработке данных для машинного обучения
- Анализе характеристик систем в инженерии  
- Решении задач оптимизации
- Обработке изображений (поиск минимальной интенсивности пикселей)

Для больших матриц последовательная обработка становится узким местом, что обуславливает необходимость применения параллельных вычислений.


## 2. Постановка задачи
Дана матрица A размером M×N, состоящая из целых чисел.

Требуется найти вектор минимальных значений для каждой строки матрицы.

Тип входных данных:
```cpp
using InType = std::vector<std::vector<int>>;
```
Тип выходных данных:
```cpp
using OutType = std::vector<int>;
```
Ограничения:
- M, N > 0
- Все строки матрицы имеют одинаковую длину
- Матрица не содержит знаков препинания или специальных символов

## 3. Базовый алгоритм (Sequential)
Каждая строка матрицы проверяется на наличие минимального элемента с помощью следующего алгоритма:
```cpp
for (const auto& row : matrix) {
    int min_val = INT_MAX;
    for (int val : row) {
        if (val < min_val) {
            min_val = val;
        }
    }
    result.push_back(min_val);
}
```
То есть происходит поиск минимального значения в каждой строке матрицы. Если строка пустая, алгоритм возвращает 0 (или можно использовать INT_MAX).

## 4. Схема распараллеливания
### Краткое описание
1. Главный процесс (rank = 0) получает входную матрицу
2. Строки матрицы распределяются между всеми процессами
3. Каждый процесс находит минимумы для своих строк локально
4. Результаты собираются на главном процессе

### Алгоритм поиска минимума в строке
```cpp
int FindRowMin(const std::vector<int>& row) {
    if (row.empty()) return 0;
    int min_val = row[0];
    for (size_t i = 1; i < row.size(); ++i) {
        if (row[i] < min_val) {
            min_val = row[i];
        }
    }
    return min_val;
}
```

### Алгоритм распределения строк по процессам
```cpp
int rows_per_process = total_rows / size;
int remainder = total_rows % size;

int my_rows = rows_per_process + (rank < remainder ? 1 : 0);
int my_offset = 0;

// Вычисляем смещение для каждого процесса
for (int i = 0; i < rank; ++i) {
    int rows_for_i = rows_per_process + (i < remainder ? 1 : 0);
    my_offset += rows_for_i;
}
```

### Схема параллельной работы алгоритма
1. Каждый процесс принимает входные данные и определяет общее количество процессов и свой ранг (size и rank)
2. Главный процесс распределяет строки матрицы между процессами с помощью MPI_Scatterv
3. Каждый процесс находит минимумы для своих строк локально
4. Результаты собираются на главном процессе с помощью MPI_Gatherv
5. Главный процесс возвращает итоговый вектор минимумов

## 5. Детали реализации
| Файл | Назначение |
|------|------------|
| common.hpp | Определение входных, выходных типов задачи |
| ops_seq.hpp/.cpp | Последовательная реализация |
| ops_mpi.hpp/.cpp | MPI-реализация с распределением данных |
| tests/functional/main.cpp | Функциональные тесты |
| tests/performance/main.cpp | Тесты производительности |

## 6. Экспериментальная среда
| Компонент | Значение |
|-----------|----------|
| CPU | Процессор системы |
| RAM | Объем оперативной памяти |
| ОС | Windows 10/11 |
| Компилятор | GCC 13.3.0 (g++), C++20, CMake, Release |
| MPI | Microsoft MPI |

## 7. Результаты и обсуждение
### 7.1 Корректность
Для функциональных тестов: 7 тестов, проверяющих различные случаи работы алгоритма.

Тесты SEQ версии (все пройдены):
1. Test1 - матрица 2×2 → {1, 2}
2. Test2 - матрица с отрицательными числами → {-5, -2}
3. Test3 - одна строка → {1}
4. Test4 - матрица 3×4 → {1, 5, 9}
5. SingleElement - матрица 1×1 → {5}
6. AllSameElements - все элементы одинаковые → {7, 7}
7. NegativeNumbers - только отрицательные числа → {-10, -8}

Тесты валидации (все пройдены):
1. EmptyMatrix - пустая матрица (невалидно)
2. EmptyRow - пустая строка (невалидно)
3. DifferentRowSizes - строки разной длины (невалидно)

MPI тесты: Требуют запуска через mpirun, проверяют корректность параллельной реализации.

### 7.2 Производительность
Для тестов производительности: генерируется матрица 1000×1000 со случайными числами.

| Режим | Время, сек | Ускорение | Эффективность |
|-------|------------|-----------|---------------|
| SEQ (pipeline) | 0.002754 | 1.00 | 100% |
| SEQ (task_run) | 0.003001 | 0.92 | 92% |
| MPI (pipeline) | 0.017266 | 0.16 | 4%* |
| MPI (task_run) | 0.017679 | 0.16 | 4%* |

*Примечание: Для матрицы 1000×1000 накладные расходы MPI превышают выгоду от параллелизации. MPI покажет преимущество на более крупных матрицах.*

## 8. Заключение
В ходе выполнения работы удалось реализовать алгоритм нахождения минимальных элементов в строках матрицы, распараллелить его при помощи MPI и провести всестороннее тестирование.
